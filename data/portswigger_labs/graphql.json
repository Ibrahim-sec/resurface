[
  {
    "url": "https://portswigger.net/web-security/graphql/lab-graphql-accidental-field-exposure",
    "category": "graphql",
    "title": "Accidental exposure of private GraphQL fields",
    "description": "The user management functions for this lab are powered by a GraphQL endpoint. The lab contains an access control vulnerability whereby you can induce the API to reveal user credential fields.",
    "solution_steps": [
      "In Burp's browser, access the lab and select My account .",
      "Attempt to log in to the site.",
      "In Burp, go to Proxy > HTTP history and notice that the login attempt is sent as a GraphQL mutation containing a username and password.",
      "Right-click the login request and select Send to Repeater .",
      "In Repeater, right-click anywhere within the Request panel of the message editor and select GraphQL > Set introspection query to insert an introspection query into the request body.",
      "Send the request.",
      "Right-click the message and select GraphQL > Save GraphQL queries to site map .",
      "Go to Target > Site map and review the GraphQL queries. Notice the following: There is a getUser query that returns a user's username and password. This query fetches the relevant user information via a direct reference to an id number."
    ],
    "solution": "1. In Burp's browser, access the lab and select My account .\n2. Attempt to log in to the site.\n3. In Burp, go to Proxy > HTTP history and notice that the login attempt is sent as a GraphQL mutation containing a username and password.\n4. Right-click the login request and select Send to Repeater .\n5. In Repeater, right-click anywhere within the Request panel of the message editor and select GraphQL > Set introspection query to insert an introspection query into the request body.\n6. Send the request.\n7. Right-click the message and select GraphQL > Save GraphQL queries to site map .\n8. Go to Target > Site map and review the GraphQL queries. Notice the following: There is a getUser query that returns a user's username and password. This query fetches the relevant user information via a direct reference to an id number.",
    "payloads": [
      "carlos",
      "getUser"
    ]
  },
  {
    "url": "https://portswigger.net/web-security/graphql/lab-graphql-brute-force-protection-bypass",
    "category": "graphql",
    "title": "Bypassing GraphQL brute force protections",
    "description": "The user login mechanism for this lab is powered by a GraphQL API. The API endpoint has a rate limiter that returns an error if it receives too many requests from the same origin in a short space of time.",
    "solution_steps": [
      "Open the lab in Burp's browser.",
      "Right-click the page and select Inspect .",
      "Select the Console tab.",
      "Paste the script and press Enter."
    ],
    "solution": "1. Open the lab in Burp's browser.\n2. Right-click the page and select Inspect .\n3. Select the Console tab.\n4. Paste the script and press Enter.",
    "payloads": [
      "carlos",
      "mutation {}",
      "operationName",
      "success",
      "mutation {\n        bruteforce0:login(input:{password: \"123456\", username: \"carlos\"}) {\n              token\n              success\n          }\n\n          bruteforce1:login(input:{password: \"password\", username: \"carlos\"}) {\n              token\n              success\n          }\n\n    ...\n\n          bruteforce99:login(input:{password: \"12345678\", username: \"carlos\"}) {\n              token\n              success\n          }\n    }",
      "true"
    ]
  },
  {
    "url": "https://portswigger.net/web-security/graphql/lab-graphql-csrf-via-graphql-api",
    "category": "graphql",
    "title": "Performing CSRF exploits over GraphQL",
    "description": "The user management functions for this lab are powered by a GraphQL endpoint. The endpoint accepts requests with a content-type ofx-www-form-urlencodedand is therefore vulnerable to cross-site request forgery (CSRF) attacks.",
    "solution_steps": [
      "Open Burp's browser, access the lab and log in to your account.",
      "Enter a new email address, then click Update email .",
      "In Burp, go to Proxy > HTTP history and check the resulting request. Note that the email change is sent as a GraphQL mutation.",
      "Right-click the email change request and select Send to Repeater .",
      "In Repeater, amend the GraphQL query to change the email to a second different address.",
      "Click Send .",
      "In the response, notice that the email has changed again. This indicates that you can reuse a session cookie to send multiple requests.",
      "Convert the request into a POST request with a Content-Type of x-www-form-urlencoded . To do this, right-click the request and select Change request method twice.",
      "Notice that the mutation request body has been deleted. Add the request body back in with URL encoding. The body should look like the below: query=%0A++++mutation+changeEmail%28%24input%3A+ChangeEmailInput%21%29+%7B%0A++++++++changeEmail%28input%3A+%24input%29+%7B%0A++++++++++++email%0A++++++++%7D%0A++++%7D%0A&operationName=changeEmail&variables=%7B%22input%22%3A%7B%22email%22%3A%22hacker%40hacker.com%22%7D%7D",
      "Right-click the request and select Engagement tools > Generate CSRF PoC . Burp displays the CSRF PoC generator dialog.",
      "Amend the HTML in the CSRF PoC generator dialog so that it changes the email a third time. This step is necessary because otherwise the exploit won't make any changes to the current email address at the time it is run. Likewise, if you test the exploit before delivering, make sure that you change the email from whatever it is currently set to before delivering to the victim.",
      "Copy the HTML.",
      "In the lab, click Go to exploit server .",
      "Paste the HTML into the exploit server and click Deliver exploit to victim to solve the lab."
    ],
    "solution": "1. Open Burp's browser, access the lab and log in to your account.\n2. Enter a new email address, then click Update email .\n3. In Burp, go to Proxy > HTTP history and check the resulting request. Note that the email change is sent as a GraphQL mutation.\n4. Right-click the email change request and select Send to Repeater .\n5. In Repeater, amend the GraphQL query to change the email to a second different address.\n6. Click Send .\n7. In the response, notice that the email has changed again. This indicates that you can reuse a session cookie to send multiple requests.\n8. Convert the request into a POST request with a Content-Type of x-www-form-urlencoded . To do this, right-click the request and select Change request method twice.\n9. Notice that the mutation request body has been deleted. Add the request body back in with URL encoding. The body should look like the below: query=%0A++++mutation+changeEmail%28%24input%3A+ChangeEmailInput%21%29+%7B%0A++++++++changeEmail%28input%3A+%24input%29+%7B%0A++++++++++++email%0A++++++++%7D%0A++++%7D%0A&operationName=changeEmail&variables=%7B%22input%22%3A%7B%22email%22%3A%22hacker%40hacker.com%22%7D%7D\n10. Right-click the request and select Engagement tools > Generate CSRF PoC . Burp displays the CSRF PoC generator dialog.\n11. Amend the HTML in the CSRF PoC generator dialog so that it changes the email a third time. This step is necessary because otherwise the exploit won't make any changes to the current email address at the time it is run. Likewise, if you test the exploit before delivering, make sure that you change the email from whatever it is currently set to before delivering to the victim.\n12. Copy the HTML.\n13. In the lab, click Go to exploit server .\n14. Paste the HTML into the exploit server and click Deliver exploit to victim to solve the lab.",
    "payloads": [
      "x-www-form-urlencoded",
      "wiener:peter",
      "Content-Type",
      "query=%0A++++mutation+changeEmail%28%24input%3A+ChangeEmailInput%21%29+%7B%0A++++++++changeEmail%28input%3A+%24input%29+%7B%0A++++++++++++email%0A++++++++%7D%0A++++%7D%0A&operationName=changeEmail&variables=%7B%22input%22%3A%7B%22email%22%3A%22hacker%40hacker.com%22%7D%7D"
    ]
  },
  {
    "url": "https://portswigger.net/web-security/graphql/lab-graphql-find-the-endpoint",
    "category": "graphql",
    "title": "Finding a hidden GraphQL endpoint",
    "description": "The user management functions for this lab are powered by a hidden GraphQL endpoint. You won't be able to find this endpoint by simply clicking pages in the site. The endpoint also has some defenses against introspection.",
    "solution_steps": [
      "In Repeater, send requests to some common GraphQL endpoint suffixes and inspect the results.",
      "Note that when you send a GET request to /api the response contains a \"Query not present\" error. This hints that there may be a GraphQL endpoint responding to GET requests at this location.",
      "Amend the request to contain a universal query. Note that, because the endpoint is responding to GET requests, you need to send the query as a URL parameter. For example: /api?query=query{__typename} .",
      "Notice that the response confirms that this is a GraphQL endpoint: {\n  \"data\": {\n    \"__typename\": \"query\"\n  }\n}"
    ],
    "solution": "1. In Repeater, send requests to some common GraphQL endpoint suffixes and inspect the results.\n2. Note that when you send a GET request to /api the response contains a \"Query not present\" error. This hints that there may be a GraphQL endpoint responding to GET requests at this location.\n3. Amend the request to contain a universal query. Note that, because the endpoint is responding to GET requests, you need to send the query as a URL parameter. For example: /api?query=query{__typename} .\n4. Notice that the response confirms that this is a GraphQL endpoint: {\n  \"data\": {\n    \"__typename\": \"query\"\n  }\n}",
    "payloads": [
      "carlos",
      "/api",
      "/api?query=query{__typename}",
      "{\n  \"data\": {\n    \"__typename\": \"query\"\n  }\n}",
      "__schema",
      "\"__schema{\"",
      "getUser",
      "{\n\"data\": {\n\"getUser\": null\n}\n}",
      "deleteOrganizationUser",
      "/api?query=mutation+%7B%0A%09deleteOrganizationUser%28input%3A%7Bid%3A+3%7D%29+%7B%0A%09%09user+%7B%0A%09%09%09id%0A%09%09%7D%0A%09%7D%0A%7D"
    ]
  },
  {
    "url": "https://portswigger.net/web-security/graphql/lab-graphql-reading-private-posts",
    "category": "graphql",
    "title": "Accessing private GraphQL posts",
    "description": "The blog page for this lab contains a hidden blog post that has a secret password. To solve the lab, find the hidden blog post and enter the password.",
    "solution_steps": [
      "In Burp's browser, access the blog page.",
      "In Burp, go to Proxy > HTTP history and notice the following: Blog posts are retrieved using a GraphQL query. In the response to the GraphQL query, each blog post has its own sequential id . Blog post id 3 is missing from the list. This indicates that there is a hidden blog post.",
      "Find the POST /graphql/v1 request. Right-click it and select Send to Repeater .",
      "In Repeater, right-click anywhere in the Request panel of the message editor and select GraphQL > Set introspection query to insert an introspection query into the request body.",
      "Send the request. Notice in the response that the BlogPost type has a postPassword field available."
    ],
    "solution": "1. In Burp's browser, access the blog page.\n2. In Burp, go to Proxy > HTTP history and notice the following: Blog posts are retrieved using a GraphQL query. In the response to the GraphQL query, each blog post has its own sequential id . Blog post id 3 is missing from the list. This indicates that there is a hidden blog post.\n3. Find the POST /graphql/v1 request. Right-click it and select Send to Repeater .\n4. In Repeater, right-click anywhere in the Request panel of the message editor and select GraphQL > Set introspection query to insert an introspection query into the request body.\n5. Send the request. Notice in the response that the BlogPost type has a postPassword field available.",
    "payloads": [
      "POST /graphql/v1",
      "BlogPost",
      "postPassword"
    ]
  }
]