#!/usr/bin/env python3
"""
Convert Exploit-DB exploits to training data format.
Extracts vulnerability info and structures it for fine-tuning.
"""
import json
import re
from pathlib import Path
from typing import Optional

REPORTS_DIR = Path(__file__).parent.parent / "data" / "exploitdb"
OUTPUT_FILE = Path(__file__).parent / "data" / "train_exploitdb.jsonl"


def extract_methodology(code: str, vuln_type: str) -> str:
    """Extract exploitation methodology from exploit code."""
    lines = code.split('\n')
    
    # Look for comments that describe the exploit
    methodology = []
    in_header = True
    
    for line in lines[:100]:  # Check first 100 lines
        line = line.strip()
        
        # Skip empty lines at start
        if not line and in_header:
            continue
        
        # Capture comment blocks
        if line.startswith('#') or line.startswith('//') or line.startswith('*'):
            clean = line.lstrip('#/*').strip()
            if clean and len(clean) > 10:
                methodology.append(clean)
            in_header = False
        elif line.startswith('"""') or line.startswith("'''"):
            in_header = False
        elif in_header:
            in_header = False
    
    if methodology:
        return '\n'.join(methodology[:20])
    
    # Fallback: generate based on vuln type
    return f"Exploit code for {vuln_type} vulnerability. Review the code for specific exploitation steps."


def extract_payloads(code: str) -> str:
    """Extract payloads from exploit code."""
    payloads = []
    
    # Common payload patterns
    patterns = [
        r"payload\s*=\s*['\"](.+?)['\"]",
        r"shell\s*=\s*['\"](.+?)['\"]",
        r"cmd\s*=\s*['\"](.+?)['\"]",
        r"query\s*=\s*['\"](.+?)['\"]",
        r"exploit\s*=\s*['\"](.+?)['\"]",
    ]
    
    for pattern in patterns:
        matches = re.findall(pattern, code, re.IGNORECASE)
        for m in matches[:5]:
            if len(m) > 10 and len(m) < 200:
                payloads.append(f"- `{m[:100]}`")
    
    if payloads:
        return '\n'.join(payloads[:10])
    return "- See exploit code for specific payloads"


def get_indicators(vuln_type: str) -> str:
    """Get success indicators based on vulnerability type."""
    indicators = {
        "sqli": "- Database data retrieved\n- SQL error messages\n- UNION query successful",
        "xss_reflected": "- JavaScript executed\n- Alert/popup displayed\n- Cookie accessible",
        "rce": "- Command output visible\n- Shell spawned\n- File created on server",
        "path_traversal": "- File contents visible\n- Directory listing obtained",
        "auth_bypass": "- Logged in without credentials\n- Admin access obtained",
        "file_upload": "- Shell uploaded\n- Code execution achieved",
    }
    return indicators.get(vuln_type, "- Exploit successful\n- Unauthorized access achieved")


def convert_exploit(exploit: dict) -> Optional[dict]:
    """Convert a single exploit to training format."""
    code = exploit.get("code", "")
    if not code or len(code) < 100:
        return None
    
    title = exploit.get("title", "Unknown Exploit")
    vuln_type = exploit.get("vuln_type", "unknown")
    
    methodology = extract_methodology(code, vuln_type)
    payloads = extract_payloads(code)
    indicators = get_indicators(vuln_type)
    
    # Build training example
    user_content = f"""You are a security researcher testing a web application for vulnerabilities.

**Vulnerability Type:** {vuln_type}
**Scenario:** {title}

Generate a step-by-step exploitation methodology for this vulnerability. Include:
1. Detailed exploitation steps
2. Key payloads to use
3. Indicators that confirm successful exploitation"""

    assistant_content = f"""## Exploitation Methodology: {title}

### Step-by-Step Exploitation
{methodology}

### Key Payloads
{payloads}

### Success Indicators
{indicators}"""

    return {
        "messages": [
            {"role": "user", "content": user_content},
            {"role": "assistant", "content": assistant_content}
        ]
    }


def main():
    if not REPORTS_DIR.exists():
        print(f"Reports directory not found: {REPORTS_DIR}")
        return
    
    converted = []
    skipped = 0
    
    for exploit_file in sorted(REPORTS_DIR.glob("*.json")):
        try:
            with open(exploit_file) as f:
                exploit = json.load(f)
            
            example = convert_exploit(exploit)
            if example:
                converted.append(example)
                print(f"✅ {exploit_file.name}: {exploit.get('title', 'Unknown')[:50]}")
            else:
                skipped += 1
        except Exception as e:
            print(f"❌ {exploit_file.name}: {e}")
            skipped += 1
    
    print(f"\nConverted: {len(converted)} | Skipped: {skipped}")
    
    if converted:
        OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(OUTPUT_FILE, 'w') as f:
            for ex in converted:
                f.write(json.dumps(ex) + '\n')
        print(f"Saved to: {OUTPUT_FILE}")


if __name__ == "__main__":
    main()
